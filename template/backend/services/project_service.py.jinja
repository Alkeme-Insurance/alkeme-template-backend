"""Project service - business logic for project operations."""

from __future__ import annotations

from datetime import datetime

from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorDatabase

from backend.models.project import ProjectCreate, ProjectPublic, ProjectUpdate


class ProjectService:
    """Business logic for project operations."""

    def __init__(self, db: AsyncIOMotorDatabase):
        """Initialize project service with database."""
        self.collection = db["projects"]

    async def create_project(
        self, project_data: ProjectCreate, owner_id: str
    ) -> ProjectPublic:
        """Create a new project."""
        # Create project document
        project_dict = project_data.model_dump()
        project_dict["owner_id"] = owner_id
        project_dict["created_at"] = datetime.utcnow()

        result = await self.collection.insert_one(project_dict)
        project_dict["_id"] = str(result.inserted_id)

        return ProjectPublic(**project_dict)

    async def get_project_by_id(self, project_id: str) -> ProjectPublic | None:
        """Get project by ID."""
        if not ObjectId.is_valid(project_id):
            return None

        project = await self.collection.find_one({"_id": ObjectId(project_id)})
        if project:
            project["_id"] = str(project["_id"])
            return ProjectPublic(**project)
        return None

    async def list_projects(
        self, owner_id: str | None = None, skip: int = 0, limit: int = 10
    ) -> list[ProjectPublic]:
        """List projects with optional owner filter and pagination."""
        query = {"owner_id": owner_id} if owner_id else {}
        cursor = self.collection.find(query).skip(skip).limit(limit)
        projects = await cursor.to_list(length=limit)

        for project in projects:
            project["_id"] = str(project["_id"])

        return [ProjectPublic(**project) for project in projects]

    async def update_project(
        self, project_id: str, project_data: ProjectUpdate
    ) -> ProjectPublic | None:
        """Update project."""
        if not ObjectId.is_valid(project_id):
            return None

        update_dict = project_data.model_dump(exclude_unset=True)
        if not update_dict:
            return await self.get_project_by_id(project_id)

        update_dict["updated_at"] = datetime.utcnow()

        result = await self.collection.update_one(
            {"_id": ObjectId(project_id)}, {"$set": update_dict}
        )

        if result.matched_count == 0:
            return None

        return await self.get_project_by_id(project_id)

    async def delete_project(self, project_id: str) -> bool:
        """Delete project."""
        if not ObjectId.is_valid(project_id):
            return False

        result = await self.collection.delete_one({"_id": ObjectId(project_id)})
        return result.deleted_count > 0

